from typer import Option as Opt
from typing import Annotated as Atd

def shoot(
    traj: Atd[str, Opt("-traj", help = "a configuration file, trajectory file, or traj.txt file")] = "traj.txt",
    toml: Atd[str, Opt("-toml", help = "toml file from which engine settings and interfaces are read")] = "infretis.toml",
    name: Atd[str, Opt("-name", help = "working directory. The final path is stored in name/0")] = "worker0",
    index: Atd[int, Opt("-index", help = "shoot from this frame from a trajectory or traj.txt file")] = 0,
    seed: Atd[int, Opt("-fixed_seed", help = "Fixes the random seed if set to a positive integer. -1 yields random seed.")] = -1,
    ):
    """Generate a path by performing a shooting move from a configuration.


    Perform a regular shooting move from a configuration, trajectory or
    traj.txt file and generate a valid path. If the initial orderparameter
    value is below lambda_0, a [0-] path is created. If not, a [0+] path is
    created. This script also takes into account the lambda_minus_one interface.

    As an example, a [0-] and [0+] path can be generated by invoking

    inft shoot -traj start.g96 -toml shoot.toml -name 'pathA'

    inft shoot -traj 'pathA/0/traj.txt' -toml shoot.toml -name pathB -index 0

    """
    import pathlib
    import numpy as np
    import tomli
    import tomli_w

    from infretis.setup import setup_config
    from infretis.classes.engines.factory import create_engine
    from infretis.classes.orderparameter import create_orderparameter
    from infretis.classes.system import System
    from infretis.classes.path import Path
    from infretis.core.tis import shoot
    from infretis.classes.formatter import PathStorage

    traj = pathlib.Path(traj)
    if not traj.exists():
        exit(f"[ERROR] '{traj.resolve()}' does not exist.")

    # check if traj.txt file or not (or traj_xtc.txt file)
    if "traj" in traj.stem and traj.suffix == ".txt":
        traj_txt = np.loadtxt(traj, dtype=str, comments=["#"])
        conf = traj.parent / "accepted" / traj_txt[index, 1]
        index = int(traj_txt[index, 2])

    wdir = pathlib.Path(name)
    if not wdir.exists():
        wdir.mkdir()

    # the infretis path will be saved in wdir/0
    if (wdir / "0").exists():
        exit(f"[ERROR] '{wdir/'0'}' already exists!")
    else:
        print(f"* infretis path will be saved in {wdir/'0'}")

    # setup stuff, avoid certain errors like too many workers
    tmp_toml = pathlib.Path(wdir / "shoot.toml").resolve()
    with open(toml, "rb") as rfile:
        with open(tmp_toml, "wb") as wfile:
            config = tomli.load(rfile)
            config["workers"] = 1
            tomli_w.dump(config, wfile)

    config = setup_config(str(tmp_toml))
    config["simulation"]["tis_set"]["allowmaxlength"] = True
    engine = create_engine(config)
    engine.order_function = create_orderparameter(config)
    if seed > -1:
        engine.rgen = np.random.default_rng(seed=seed)
    else:
        engine.rgen = np.random.default_rng()

    print(f"* Setting exe_dir to {wdir.resolve()}")
    engine.exe_dir = wdir.resolve()

    intf = config["simulation"]["interfaces"]
    path = Path()
    shooting_point = System()
    shooting_point.config = (conf, index)
    # calculate order, this defines the starting conditions
    # if op < intf[0] we assume [0-] path
    # if op >= intf[0] and op < intf[-1] we assume [N+] path
    # if op >= intf[-1] what should we do?
    # modify velocities, which dumps the shooting point to genvel.ext
    engine.modify_velocities(shooting_point, config["simulation"]["tis_set"])
    # now calculate orderp after vel generation, as order may depend on vels
    order = engine.calculate_order(shooting_point)
    shooting_point.order = order
    print(f"* Initial orderparameter value: {order}")
    if order[0] < intf[0]:
        l_minus = config["simulation"]["tis_set"].get("lambda_minus_one", False)
        if l_minus:
            ens_intf = (l_minus,intf[0],intf[0])
            start_cond = ("L","R")
        else:
            ens_intf = (-float("inf"), intf[0],intf[0])
            start_cond = ("R")
    elif order[0] >= intf[0]:
        ens_intf = (intf[0],intf[0],intf[-1])
        start_cond = ("L")
    else:
        exit(f"[ERROR] order value >= interface[-1] ({intf[-1]})!"
        " Not sure what you want to do here.")

    ens_set = {
            "interfaces": ens_intf,
            "tis_set": config["simulation"]["tis_set"],
            "mc_move": "sh",
            "ens_name": name,
            "start_cond": (start_cond),
            "rgen": engine.rgen,
            }
    success, out_path, status = shoot(ens_set, path, engine, shooting_point, start_cond)
    out_path.path_number = 0
    pstore = PathStorage()
    pstore.keep_traj_fnames = config.get("output",{}).get("keep_traj_fnames",[])
    pstore.output(0, {"path": out_path, "dir": wdir})
